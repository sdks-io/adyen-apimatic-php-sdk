<?php

declare(strict_types=1);

/*
 * AdyenApIsLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

namespace AdyenApIsLib\Models;

use AdyenApIsLib\ApiHelper;
use stdClass;

class AdditionalDataCommon implements \JsonSerializable
{
    /**
     * @var string|null
     */
    private $requestedTestAcquirerResponseCode;

    /**
     * @var string|null
     */
    private $requestedTestErrorResponseCode;

    /**
     * @var string|null
     */
    private $allowPartialAuth;

    /**
     * @var string|null
     */
    private $authorisationType;

    /**
     * @var string|null
     */
    private $autoRescue;

    /**
     * @var string|null
     */
    private $customRoutingFlag;

    /**
     * @var string|null
     */
    private $industryUsage;

    /**
     * @var string|null
     */
    private $manualCapture;

    /**
     * @var string|null
     */
    private $maxDaysToRescue;

    /**
     * @var string|null
     */
    private $networkTxReference;

    /**
     * @var string|null
     */
    private $overwriteBrand;

    /**
     * @var string|null
     */
    private $subMerchantCity;

    /**
     * @var string|null
     */
    private $subMerchantCountry;

    /**
     * @var string|null
     */
    private $subMerchantEmail;

    /**
     * @var string|null
     */
    private $subMerchantId;

    /**
     * @var string|null
     */
    private $subMerchantName;

    /**
     * @var string|null
     */
    private $subMerchantPhoneNumber;

    /**
     * @var string|null
     */
    private $subMerchantPostalCode;

    /**
     * @var string|null
     */
    private $subMerchantState;

    /**
     * @var string|null
     */
    private $subMerchantStreet;

    /**
     * @var string|null
     */
    private $subMerchantTaxId;

    /**
     * Returns Requested Test Acquirer Response Code.
     * Triggers test scenarios that allow to replicate certain acquirer response codes. See [Testing result
     * codes and refusal reasons](https://docs.adyen.com/development-resources/testing/result-codes/) to
     * learn about the possible values, and the `refusalReason` values you can trigger.
     */
    public function getRequestedTestAcquirerResponseCode(): ?string
    {
        return $this->requestedTestAcquirerResponseCode;
    }

    /**
     * Sets Requested Test Acquirer Response Code.
     * Triggers test scenarios that allow to replicate certain acquirer response codes. See [Testing result
     * codes and refusal reasons](https://docs.adyen.com/development-resources/testing/result-codes/) to
     * learn about the possible values, and the `refusalReason` values you can trigger.
     *
     * @maps RequestedTestAcquirerResponseCode
     */
    public function setRequestedTestAcquirerResponseCode(?string $requestedTestAcquirerResponseCode): void
    {
        $this->requestedTestAcquirerResponseCode = $requestedTestAcquirerResponseCode;
    }

    /**
     * Returns Requested Test Error Response Code.
     * Triggers test scenarios that allow to replicate certain communication errors.
     *
     * Allowed values:
     * * **NO_CONNECTION_AVAILABLE** – There wasn't a connection available to service the outgoing
     * communication.
     * This is a transient, retriable error since no messaging could be initiated to an issuing system (or
     * third-party acquiring system). Therefore, the header Transient-Error: true is returned in the
     * response. A subsequent request using the same idempotency key will be processed as if it was the
     * first request.
     * * **IOEXCEPTION_RECEIVED** – Something went wrong during transmission of the message or receiving
     * the response.
     * This is a classified as non-transient because the message could have been received by the issuing
     * party and been acted upon. No transient error header is returned. If using idempotency, the (error)
     * response is stored as the final result for the idempotency key. Subsequent messages with the same
     * idempotency key not be processed beyond returning the stored response.
     */
    public function getRequestedTestErrorResponseCode(): ?string
    {
        return $this->requestedTestErrorResponseCode;
    }

    /**
     * Sets Requested Test Error Response Code.
     * Triggers test scenarios that allow to replicate certain communication errors.
     *
     * Allowed values:
     * * **NO_CONNECTION_AVAILABLE** – There wasn't a connection available to service the outgoing
     * communication.
     * This is a transient, retriable error since no messaging could be initiated to an issuing system (or
     * third-party acquiring system). Therefore, the header Transient-Error: true is returned in the
     * response. A subsequent request using the same idempotency key will be processed as if it was the
     * first request.
     * * **IOEXCEPTION_RECEIVED** – Something went wrong during transmission of the message or receiving
     * the response.
     * This is a classified as non-transient because the message could have been received by the issuing
     * party and been acted upon. No transient error header is returned. If using idempotency, the (error)
     * response is stored as the final result for the idempotency key. Subsequent messages with the same
     * idempotency key not be processed beyond returning the stored response.
     *
     * @maps RequestedTestErrorResponseCode
     */
    public function setRequestedTestErrorResponseCode(?string $requestedTestErrorResponseCode): void
    {
        $this->requestedTestErrorResponseCode = $requestedTestErrorResponseCode;
    }

    /**
     * Returns Allow Partial Auth.
     * Set to true to authorise a part of the requested amount in case the cardholder does not have enough
     * funds on their account.
     * If a payment was partially authorised, the response includes resultCode: PartiallyAuthorised and the
     * authorised amount in additionalData.authorisedAmountValue.
     * To enable this functionality, contact our Support Team.
     */
    public function getAllowPartialAuth(): ?string
    {
        return $this->allowPartialAuth;
    }

    /**
     * Sets Allow Partial Auth.
     * Set to true to authorise a part of the requested amount in case the cardholder does not have enough
     * funds on their account.
     * If a payment was partially authorised, the response includes resultCode: PartiallyAuthorised and the
     * authorised amount in additionalData.authorisedAmountValue.
     * To enable this functionality, contact our Support Team.
     *
     * @maps allowPartialAuth
     */
    public function setAllowPartialAuth(?string $allowPartialAuth): void
    {
        $this->allowPartialAuth = $allowPartialAuth;
    }

    /**
     * Returns Authorisation Type.
     * Flags a card payment request for either pre-authorisation or final authorisation. For more
     * information, refer to [Authorisation types](https://docs.adyen.com/online-payments/adjust-
     * authorisation#authorisation-types).
     *
     * Allowed values:
     * * **PreAuth** – flags the payment request to be handled as a pre-authorisation.
     * * **FinalAuth** – flags the payment request to be handled as a final authorisation.
     */
    public function getAuthorisationType(): ?string
    {
        return $this->authorisationType;
    }

    /**
     * Sets Authorisation Type.
     * Flags a card payment request for either pre-authorisation or final authorisation. For more
     * information, refer to [Authorisation types](https://docs.adyen.com/online-payments/adjust-
     * authorisation#authorisation-types).
     *
     * Allowed values:
     * * **PreAuth** – flags the payment request to be handled as a pre-authorisation.
     * * **FinalAuth** – flags the payment request to be handled as a final authorisation.
     *
     * @maps authorisationType
     */
    public function setAuthorisationType(?string $authorisationType): void
    {
        $this->authorisationType = $authorisationType;
    }

    /**
     * Returns Auto Rescue.
     * Set to **true** to enable [Auto Rescue](https://docs.adyen.com/online-payments/auto-rescue/) for a
     * transaction. Use the `maxDaysToRescue` to specify a rescue window.
     */
    public function getAutoRescue(): ?string
    {
        return $this->autoRescue;
    }

    /**
     * Sets Auto Rescue.
     * Set to **true** to enable [Auto Rescue](https://docs.adyen.com/online-payments/auto-rescue/) for a
     * transaction. Use the `maxDaysToRescue` to specify a rescue window.
     *
     * @maps autoRescue
     */
    public function setAutoRescue(?string $autoRescue): void
    {
        $this->autoRescue = $autoRescue;
    }

    /**
     * Returns Custom Routing Flag.
     * Allows you to determine or override the acquirer account that should be used for the transaction.
     *
     * If you need to process a payment with an acquirer different from a default one, you can set up a
     * corresponding configuration on the Adyen payments platform. Then you can pass a custom routing flag
     * in a payment request's additional data to target a specific acquirer.
     *
     * To enable this functionality, contact [Support](https://www.adyen.help/hc/en-us/requests/new).
     */
    public function getCustomRoutingFlag(): ?string
    {
        return $this->customRoutingFlag;
    }

    /**
     * Sets Custom Routing Flag.
     * Allows you to determine or override the acquirer account that should be used for the transaction.
     *
     * If you need to process a payment with an acquirer different from a default one, you can set up a
     * corresponding configuration on the Adyen payments platform. Then you can pass a custom routing flag
     * in a payment request's additional data to target a specific acquirer.
     *
     * To enable this functionality, contact [Support](https://www.adyen.help/hc/en-us/requests/new).
     *
     * @maps customRoutingFlag
     */
    public function setCustomRoutingFlag(?string $customRoutingFlag): void
    {
        $this->customRoutingFlag = $customRoutingFlag;
    }

    /**
     * Returns Industry Usage.
     * In case of [asynchronous authorisation adjustment](https://docs.adyen.com/online-payments/adjust-
     * authorisation#adjust-authorisation), this field denotes why the additional payment is made.
     *
     * Possible values:
     *
     * * **NoShow**: An incremental charge is carried out because of a no-show for a guaranteed
     * reservation.
     *
     * * **DelayedCharge**: An incremental charge is carried out to process an additional payment after
     * the original services have been rendered and the respective payment has been processed.
     */
    public function getIndustryUsage(): ?string
    {
        return $this->industryUsage;
    }

    /**
     * Sets Industry Usage.
     * In case of [asynchronous authorisation adjustment](https://docs.adyen.com/online-payments/adjust-
     * authorisation#adjust-authorisation), this field denotes why the additional payment is made.
     *
     * Possible values:
     *
     * * **NoShow**: An incremental charge is carried out because of a no-show for a guaranteed
     * reservation.
     *
     * * **DelayedCharge**: An incremental charge is carried out to process an additional payment after
     * the original services have been rendered and the respective payment has been processed.
     *
     * @maps industryUsage
     * @factory \AdyenApIsLib\Models\IndustryUsage::checkValue
     */
    public function setIndustryUsage(?string $industryUsage): void
    {
        $this->industryUsage = $industryUsage;
    }

    /**
     * Returns Manual Capture.
     * Set to **true** to require [manual capture](https://docs.adyen.com/online-payments/capture) for the
     * transaction.
     */
    public function getManualCapture(): ?string
    {
        return $this->manualCapture;
    }

    /**
     * Sets Manual Capture.
     * Set to **true** to require [manual capture](https://docs.adyen.com/online-payments/capture) for the
     * transaction.
     *
     * @maps manualCapture
     */
    public function setManualCapture(?string $manualCapture): void
    {
        $this->manualCapture = $manualCapture;
    }

    /**
     * Returns Max Days to Rescue.
     * The rescue window for a transaction, in days, when `autoRescue` is set to **true**. You can specify
     * a value between 1 and 48.
     *
     * * For [cards](https://docs.adyen.com/online-payments/auto-rescue/cards/), the default is one
     * calendar month.
     * * For [SEPA](https://docs.adyen.com/online-payments/auto-rescue/sepa/), the default is 42 days.
     */
    public function getMaxDaysToRescue(): ?string
    {
        return $this->maxDaysToRescue;
    }

    /**
     * Sets Max Days to Rescue.
     * The rescue window for a transaction, in days, when `autoRescue` is set to **true**. You can specify
     * a value between 1 and 48.
     *
     * * For [cards](https://docs.adyen.com/online-payments/auto-rescue/cards/), the default is one
     * calendar month.
     * * For [SEPA](https://docs.adyen.com/online-payments/auto-rescue/sepa/), the default is 42 days.
     *
     * @maps maxDaysToRescue
     */
    public function setMaxDaysToRescue(?string $maxDaysToRescue): void
    {
        $this->maxDaysToRescue = $maxDaysToRescue;
    }

    /**
     * Returns Network Tx Reference.
     * Allows you to link the transaction to the original or previous one in a subscription/card-on-file
     * chain. This field is required for token-based transactions where Adyen does not tokenize the card.
     *
     * Transaction identifier from card schemes, for example, Mastercard Trace ID or the Visa Transaction
     * ID.
     *
     * Submit the original transaction ID of the contract in your payment request if you are not tokenizing
     * card details with Adyen and are making a merchant-initiated transaction (MIT) for subsequent charges.
     *
     * Make sure you are sending `shopperInteraction` **ContAuth** and `recurringProcessingModel`
     * **Subscription** or **UnscheduledCardOnFile** to ensure that the transaction is classified as MIT.
     */
    public function getNetworkTxReference(): ?string
    {
        return $this->networkTxReference;
    }

    /**
     * Sets Network Tx Reference.
     * Allows you to link the transaction to the original or previous one in a subscription/card-on-file
     * chain. This field is required for token-based transactions where Adyen does not tokenize the card.
     *
     * Transaction identifier from card schemes, for example, Mastercard Trace ID or the Visa Transaction
     * ID.
     *
     * Submit the original transaction ID of the contract in your payment request if you are not tokenizing
     * card details with Adyen and are making a merchant-initiated transaction (MIT) for subsequent charges.
     *
     * Make sure you are sending `shopperInteraction` **ContAuth** and `recurringProcessingModel`
     * **Subscription** or **UnscheduledCardOnFile** to ensure that the transaction is classified as MIT.
     *
     * @maps networkTxReference
     */
    public function setNetworkTxReference(?string $networkTxReference): void
    {
        $this->networkTxReference = $networkTxReference;
    }

    /**
     * Returns Overwrite Brand.
     * Boolean indicator that can be optionally used for performing debit transactions on combo cards (for
     * example, combo cards in Brazil). This is not mandatory but we recommend that you set this to true if
     * you want to use the `selectedBrand` value to specify how to process the transaction.
     */
    public function getOverwriteBrand(): ?string
    {
        return $this->overwriteBrand;
    }

    /**
     * Sets Overwrite Brand.
     * Boolean indicator that can be optionally used for performing debit transactions on combo cards (for
     * example, combo cards in Brazil). This is not mandatory but we recommend that you set this to true if
     * you want to use the `selectedBrand` value to specify how to process the transaction.
     *
     * @maps overwriteBrand
     */
    public function setOverwriteBrand(?string $overwriteBrand): void
    {
        $this->overwriteBrand = $overwriteBrand;
    }

    /**
     * Returns Sub Merchant City.
     * This field is required if the transaction is performed by a registered payment facilitator. This
     * field must contain the city of the actual merchant's address.
     * * Format: alpha-numeric.
     * * Maximum length: 13 characters.
     */
    public function getSubMerchantCity(): ?string
    {
        return $this->subMerchantCity;
    }

    /**
     * Sets Sub Merchant City.
     * This field is required if the transaction is performed by a registered payment facilitator. This
     * field must contain the city of the actual merchant's address.
     * * Format: alpha-numeric.
     * * Maximum length: 13 characters.
     *
     * @maps subMerchantCity
     */
    public function setSubMerchantCity(?string $subMerchantCity): void
    {
        $this->subMerchantCity = $subMerchantCity;
    }

    /**
     * Returns Sub Merchant Country.
     * This field is required if the transaction is performed by a registered payment facilitator. This
     * field must contain the three-letter country code of the actual merchant's address.
     * * Format: alpha-numeric.
     * * Fixed length: 3 characters.
     */
    public function getSubMerchantCountry(): ?string
    {
        return $this->subMerchantCountry;
    }

    /**
     * Sets Sub Merchant Country.
     * This field is required if the transaction is performed by a registered payment facilitator. This
     * field must contain the three-letter country code of the actual merchant's address.
     * * Format: alpha-numeric.
     * * Fixed length: 3 characters.
     *
     * @maps subMerchantCountry
     */
    public function setSubMerchantCountry(?string $subMerchantCountry): void
    {
        $this->subMerchantCountry = $subMerchantCountry;
    }

    /**
     * Returns Sub Merchant Email.
     * This field is required for transactions performed by registered payment facilitators. This field
     * contains the email address of the sub-merchant.
     * * Format: Alphanumeric
     * * Maximum length: 40 characters
     */
    public function getSubMerchantEmail(): ?string
    {
        return $this->subMerchantEmail;
    }

    /**
     * Sets Sub Merchant Email.
     * This field is required for transactions performed by registered payment facilitators. This field
     * contains the email address of the sub-merchant.
     * * Format: Alphanumeric
     * * Maximum length: 40 characters
     *
     * @maps subMerchantEmail
     */
    public function setSubMerchantEmail(?string $subMerchantEmail): void
    {
        $this->subMerchantEmail = $subMerchantEmail;
    }

    /**
     * Returns Sub Merchant Id.
     * This field contains an identifier of the actual merchant when a transaction is submitted via a
     * payment facilitator. The payment facilitator must send in this unique ID.
     *
     * A unique identifier per submerchant that is required if the transaction is performed by a registered
     * payment facilitator.
     * * Format: alpha-numeric.
     * * Fixed length: 15 characters.
     */
    public function getSubMerchantId(): ?string
    {
        return $this->subMerchantId;
    }

    /**
     * Sets Sub Merchant Id.
     * This field contains an identifier of the actual merchant when a transaction is submitted via a
     * payment facilitator. The payment facilitator must send in this unique ID.
     *
     * A unique identifier per submerchant that is required if the transaction is performed by a registered
     * payment facilitator.
     * * Format: alpha-numeric.
     * * Fixed length: 15 characters.
     *
     * @maps subMerchantID
     */
    public function setSubMerchantId(?string $subMerchantId): void
    {
        $this->subMerchantId = $subMerchantId;
    }

    /**
     * Returns Sub Merchant Name.
     * This field is required if the transaction is performed by a registered payment facilitator. This
     * field must contain the name of the actual merchant.
     * * Format: alpha-numeric.
     * * Maximum length: 22 characters.
     */
    public function getSubMerchantName(): ?string
    {
        return $this->subMerchantName;
    }

    /**
     * Sets Sub Merchant Name.
     * This field is required if the transaction is performed by a registered payment facilitator. This
     * field must contain the name of the actual merchant.
     * * Format: alpha-numeric.
     * * Maximum length: 22 characters.
     *
     * @maps subMerchantName
     */
    public function setSubMerchantName(?string $subMerchantName): void
    {
        $this->subMerchantName = $subMerchantName;
    }

    /**
     * Returns Sub Merchant Phone Number.
     * This field is required for transactions performed by registered payment facilitators. This field
     * contains the phone number of the sub-merchant.* Format: Alphanumeric
     * * Maximum length: 20 characters
     */
    public function getSubMerchantPhoneNumber(): ?string
    {
        return $this->subMerchantPhoneNumber;
    }

    /**
     * Sets Sub Merchant Phone Number.
     * This field is required for transactions performed by registered payment facilitators. This field
     * contains the phone number of the sub-merchant.* Format: Alphanumeric
     * * Maximum length: 20 characters
     *
     * @maps subMerchantPhoneNumber
     */
    public function setSubMerchantPhoneNumber(?string $subMerchantPhoneNumber): void
    {
        $this->subMerchantPhoneNumber = $subMerchantPhoneNumber;
    }

    /**
     * Returns Sub Merchant Postal Code.
     * This field is required if the transaction is performed by a registered payment facilitator. This
     * field must contain the postal code of the actual merchant's address.
     * * Format: alpha-numeric.
     * * Maximum length: 10 characters.
     */
    public function getSubMerchantPostalCode(): ?string
    {
        return $this->subMerchantPostalCode;
    }

    /**
     * Sets Sub Merchant Postal Code.
     * This field is required if the transaction is performed by a registered payment facilitator. This
     * field must contain the postal code of the actual merchant's address.
     * * Format: alpha-numeric.
     * * Maximum length: 10 characters.
     *
     * @maps subMerchantPostalCode
     */
    public function setSubMerchantPostalCode(?string $subMerchantPostalCode): void
    {
        $this->subMerchantPostalCode = $subMerchantPostalCode;
    }

    /**
     * Returns Sub Merchant State.
     * This field is required if the transaction is performed by a registered payment facilitator, and if
     * applicable to the country. This field must contain the state code of the actual merchant's address.
     * * Format: alpha-numeric.
     * * Maximum length: 3 characters.
     */
    public function getSubMerchantState(): ?string
    {
        return $this->subMerchantState;
    }

    /**
     * Sets Sub Merchant State.
     * This field is required if the transaction is performed by a registered payment facilitator, and if
     * applicable to the country. This field must contain the state code of the actual merchant's address.
     * * Format: alpha-numeric.
     * * Maximum length: 3 characters.
     *
     * @maps subMerchantState
     */
    public function setSubMerchantState(?string $subMerchantState): void
    {
        $this->subMerchantState = $subMerchantState;
    }

    /**
     * Returns Sub Merchant Street.
     * This field is required if the transaction is performed by a registered payment facilitator. This
     * field must contain the street of the actual merchant's address.
     * * Format: alpha-numeric.
     * * Maximum length: 60 characters.
     */
    public function getSubMerchantStreet(): ?string
    {
        return $this->subMerchantStreet;
    }

    /**
     * Sets Sub Merchant Street.
     * This field is required if the transaction is performed by a registered payment facilitator. This
     * field must contain the street of the actual merchant's address.
     * * Format: alpha-numeric.
     * * Maximum length: 60 characters.
     *
     * @maps subMerchantStreet
     */
    public function setSubMerchantStreet(?string $subMerchantStreet): void
    {
        $this->subMerchantStreet = $subMerchantStreet;
    }

    /**
     * Returns Sub Merchant Tax Id.
     * This field is required if the transaction is performed by a registered payment facilitator. This
     * field must contain the tax ID of the actual merchant.
     * * Format: alpha-numeric.
     * * Fixed length: 11 or 14 characters.
     */
    public function getSubMerchantTaxId(): ?string
    {
        return $this->subMerchantTaxId;
    }

    /**
     * Sets Sub Merchant Tax Id.
     * This field is required if the transaction is performed by a registered payment facilitator. This
     * field must contain the tax ID of the actual merchant.
     * * Format: alpha-numeric.
     * * Fixed length: 11 or 14 characters.
     *
     * @maps subMerchantTaxId
     */
    public function setSubMerchantTaxId(?string $subMerchantTaxId): void
    {
        $this->subMerchantTaxId = $subMerchantTaxId;
    }

    /**
     * Converts the AdditionalDataCommon object to a human-readable string representation.
     *
     * @return string The string representation of the AdditionalDataCommon object.
     */
    public function __toString(): string
    {
        return ApiHelper::stringify(
            'AdditionalDataCommon',
            [
                'requestedTestAcquirerResponseCode' => $this->requestedTestAcquirerResponseCode,
                'requestedTestErrorResponseCode' => $this->requestedTestErrorResponseCode,
                'allowPartialAuth' => $this->allowPartialAuth,
                'authorisationType' => $this->authorisationType,
                'autoRescue' => $this->autoRescue,
                'customRoutingFlag' => $this->customRoutingFlag,
                'industryUsage' => $this->industryUsage,
                'manualCapture' => $this->manualCapture,
                'maxDaysToRescue' => $this->maxDaysToRescue,
                'networkTxReference' => $this->networkTxReference,
                'overwriteBrand' => $this->overwriteBrand,
                'subMerchantCity' => $this->subMerchantCity,
                'subMerchantCountry' => $this->subMerchantCountry,
                'subMerchantEmail' => $this->subMerchantEmail,
                'subMerchantId' => $this->subMerchantId,
                'subMerchantName' => $this->subMerchantName,
                'subMerchantPhoneNumber' => $this->subMerchantPhoneNumber,
                'subMerchantPostalCode' => $this->subMerchantPostalCode,
                'subMerchantState' => $this->subMerchantState,
                'subMerchantStreet' => $this->subMerchantStreet,
                'subMerchantTaxId' => $this->subMerchantTaxId
            ]
        );
    }

    /**
     * Encode this object to JSON
     *
     * @param bool $asArrayWhenEmpty Whether to serialize this model as an array whenever no fields
     *        are set. (default: false)
     *
     * @return array|stdClass
     */
    #[\ReturnTypeWillChange] // @phan-suppress-current-line PhanUndeclaredClassAttribute for (php < 8.1)
    public function jsonSerialize(bool $asArrayWhenEmpty = false)
    {
        $json = [];
        if (isset($this->requestedTestAcquirerResponseCode)) {
            $json['RequestedTestAcquirerResponseCode'] = $this->requestedTestAcquirerResponseCode;
        }
        if (isset($this->requestedTestErrorResponseCode)) {
            $json['RequestedTestErrorResponseCode']    = $this->requestedTestErrorResponseCode;
        }
        if (isset($this->allowPartialAuth)) {
            $json['allowPartialAuth']                  = $this->allowPartialAuth;
        }
        if (isset($this->authorisationType)) {
            $json['authorisationType']                 = $this->authorisationType;
        }
        if (isset($this->autoRescue)) {
            $json['autoRescue']                        = $this->autoRescue;
        }
        if (isset($this->customRoutingFlag)) {
            $json['customRoutingFlag']                 = $this->customRoutingFlag;
        }
        if (isset($this->industryUsage)) {
            $json['industryUsage']                     = IndustryUsage::checkValue($this->industryUsage);
        }
        if (isset($this->manualCapture)) {
            $json['manualCapture']                     = $this->manualCapture;
        }
        if (isset($this->maxDaysToRescue)) {
            $json['maxDaysToRescue']                   = $this->maxDaysToRescue;
        }
        if (isset($this->networkTxReference)) {
            $json['networkTxReference']                = $this->networkTxReference;
        }
        if (isset($this->overwriteBrand)) {
            $json['overwriteBrand']                    = $this->overwriteBrand;
        }
        if (isset($this->subMerchantCity)) {
            $json['subMerchantCity']                   = $this->subMerchantCity;
        }
        if (isset($this->subMerchantCountry)) {
            $json['subMerchantCountry']                = $this->subMerchantCountry;
        }
        if (isset($this->subMerchantEmail)) {
            $json['subMerchantEmail']                  = $this->subMerchantEmail;
        }
        if (isset($this->subMerchantId)) {
            $json['subMerchantID']                     = $this->subMerchantId;
        }
        if (isset($this->subMerchantName)) {
            $json['subMerchantName']                   = $this->subMerchantName;
        }
        if (isset($this->subMerchantPhoneNumber)) {
            $json['subMerchantPhoneNumber']            = $this->subMerchantPhoneNumber;
        }
        if (isset($this->subMerchantPostalCode)) {
            $json['subMerchantPostalCode']             = $this->subMerchantPostalCode;
        }
        if (isset($this->subMerchantState)) {
            $json['subMerchantState']                  = $this->subMerchantState;
        }
        if (isset($this->subMerchantStreet)) {
            $json['subMerchantStreet']                 = $this->subMerchantStreet;
        }
        if (isset($this->subMerchantTaxId)) {
            $json['subMerchantTaxId']                  = $this->subMerchantTaxId;
        }

        return (!$asArrayWhenEmpty && empty($json)) ? new stdClass() : $json;
    }
}
