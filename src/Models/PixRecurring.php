<?php

declare(strict_types=1);

/*
 * AdyenApIsLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

namespace AdyenApIsLib\Models;

use AdyenApIsLib\ApiHelper;
use stdClass;

class PixRecurring implements \JsonSerializable
{
    /**
     * @var string|null
     */
    private $billingDate;

    /**
     * @var bool|null
     */
    private $businessDayOnly;

    /**
     * @var string|null
     */
    private $endsAt;

    /**
     * @var string|null
     */
    private $frequency;

    /**
     * @var Amount41|null
     */
    private $minAmount;

    /**
     * @var string|null
     */
    private $originalPspReference;

    /**
     * @var Amount42|null
     */
    private $recurringAmount;

    /**
     * @var string|null
     */
    private $recurringStatement;

    /**
     * @var bool|null
     */
    private $retryPolicy;

    /**
     * @var string|null
     */
    private $startsAt;

    /**
     * Returns Billing Date.
     * The date on which the shopper's payment method will be charged, in YYYY-MM-DD format.
     */
    public function getBillingDate(): ?string
    {
        return $this->billingDate;
    }

    /**
     * Sets Billing Date.
     * The date on which the shopper's payment method will be charged, in YYYY-MM-DD format.
     *
     * @maps billingDate
     */
    public function setBillingDate(?string $billingDate): void
    {
        $this->billingDate = $billingDate;
    }

    /**
     * Returns Business Day Only.
     * Flag used to define whether liquidation can happen only on business days
     */
    public function getBusinessDayOnly(): ?bool
    {
        return $this->businessDayOnly;
    }

    /**
     * Sets Business Day Only.
     * Flag used to define whether liquidation can happen only on business days
     *
     * @maps businessDayOnly
     */
    public function setBusinessDayOnly(?bool $businessDayOnly): void
    {
        $this->businessDayOnly = $businessDayOnly;
    }

    /**
     * Returns Ends At.
     * End date of the billing plan, in YYYY-MM-DD format. The end date must align with the frequency and
     * the start date of the billing plan. If left blank, the subscription will continue indefinitely
     * unless it is cancelled by the shopper.
     */
    public function getEndsAt(): ?string
    {
        return $this->endsAt;
    }

    /**
     * Sets Ends At.
     * End date of the billing plan, in YYYY-MM-DD format. The end date must align with the frequency and
     * the start date of the billing plan. If left blank, the subscription will continue indefinitely
     * unless it is cancelled by the shopper.
     *
     * @maps endsAt
     */
    public function setEndsAt(?string $endsAt): void
    {
        $this->endsAt = $endsAt;
    }

    /**
     * Returns Frequency.
     * The frequency at which the shopper will be charged.
     */
    public function getFrequency(): ?string
    {
        return $this->frequency;
    }

    /**
     * Sets Frequency.
     * The frequency at which the shopper will be charged.
     *
     * @maps frequency
     * @factory \AdyenApIsLib\Models\Frequency2::checkValue
     */
    public function setFrequency(?string $frequency): void
    {
        $this->frequency = $frequency;
    }

    /**
     * Returns Min Amount.
     * For a billing plan where the payment amounts are variable, the minimum amount to charge the shopper
     * for each recurring payment. When a shopper approves the billing plan, they can also specify a
     * maximum amount in their banking app.
     */
    public function getMinAmount(): ?Amount41
    {
        return $this->minAmount;
    }

    /**
     * Sets Min Amount.
     * For a billing plan where the payment amounts are variable, the minimum amount to charge the shopper
     * for each recurring payment. When a shopper approves the billing plan, they can also specify a
     * maximum amount in their banking app.
     *
     * @maps minAmount
     */
    public function setMinAmount(?Amount41 $minAmount): void
    {
        $this->minAmount = $minAmount;
    }

    /**
     * Returns Original Psp Reference.
     * The pspReference for the failed recurring payment. Find this in AUTHORISATION webhook you received
     * after the billing date.
     */
    public function getOriginalPspReference(): ?string
    {
        return $this->originalPspReference;
    }

    /**
     * Sets Original Psp Reference.
     * The pspReference for the failed recurring payment. Find this in AUTHORISATION webhook you received
     * after the billing date.
     *
     * @maps originalPspReference
     */
    public function setOriginalPspReference(?string $originalPspReference): void
    {
        $this->originalPspReference = $originalPspReference;
    }

    /**
     * Returns Recurring Amount.
     * For a billing plan where the payment amount is fixed, the amount the shopper will be charged for
     * each recurring payment.
     */
    public function getRecurringAmount(): ?Amount42
    {
        return $this->recurringAmount;
    }

    /**
     * Sets Recurring Amount.
     * For a billing plan where the payment amount is fixed, the amount the shopper will be charged for
     * each recurring payment.
     *
     * @maps recurringAmount
     */
    public function setRecurringAmount(?Amount42 $recurringAmount): void
    {
        $this->recurringAmount = $recurringAmount;
    }

    /**
     * Returns Recurring Statement.
     * The text that that will be shown on the shopper's bank statement for the recurring payments. We
     * recommend to add a descriptive text about the subscription to let your shoppers recognize your
     * recurring payments.
     * Maximum length: 35 characters.
     */
    public function getRecurringStatement(): ?string
    {
        return $this->recurringStatement;
    }

    /**
     * Sets Recurring Statement.
     * The text that that will be shown on the shopper's bank statement for the recurring payments. We
     * recommend to add a descriptive text about the subscription to let your shoppers recognize your
     * recurring payments.
     * Maximum length: 35 characters.
     *
     * @maps recurringStatement
     */
    public function setRecurringStatement(?string $recurringStatement): void
    {
        $this->recurringStatement = $recurringStatement;
    }

    /**
     * Returns Retry Policy.
     * When set to true, you can retry for failed recurring payments. The default value is true.
     */
    public function getRetryPolicy(): ?bool
    {
        return $this->retryPolicy;
    }

    /**
     * Sets Retry Policy.
     * When set to true, you can retry for failed recurring payments. The default value is true.
     *
     * @maps retryPolicy
     */
    public function setRetryPolicy(?bool $retryPolicy): void
    {
        $this->retryPolicy = $retryPolicy;
    }

    /**
     * Returns Starts At.
     * Start date of the billing plan, in YYYY-MM-DD format. The default value is the transaction date.
     */
    public function getStartsAt(): ?string
    {
        return $this->startsAt;
    }

    /**
     * Sets Starts At.
     * Start date of the billing plan, in YYYY-MM-DD format. The default value is the transaction date.
     *
     * @maps startsAt
     */
    public function setStartsAt(?string $startsAt): void
    {
        $this->startsAt = $startsAt;
    }

    /**
     * Converts the PixRecurring object to a human-readable string representation.
     *
     * @return string The string representation of the PixRecurring object.
     */
    public function __toString(): string
    {
        return ApiHelper::stringify(
            'PixRecurring',
            [
                'billingDate' => $this->billingDate,
                'businessDayOnly' => $this->businessDayOnly,
                'endsAt' => $this->endsAt,
                'frequency' => $this->frequency,
                'minAmount' => $this->minAmount,
                'originalPspReference' => $this->originalPspReference,
                'recurringAmount' => $this->recurringAmount,
                'recurringStatement' => $this->recurringStatement,
                'retryPolicy' => $this->retryPolicy,
                'startsAt' => $this->startsAt
            ]
        );
    }

    /**
     * Encode this object to JSON
     *
     * @param bool $asArrayWhenEmpty Whether to serialize this model as an array whenever no fields
     *        are set. (default: false)
     *
     * @return array|stdClass
     */
    #[\ReturnTypeWillChange] // @phan-suppress-current-line PhanUndeclaredClassAttribute for (php < 8.1)
    public function jsonSerialize(bool $asArrayWhenEmpty = false)
    {
        $json = [];
        if (isset($this->billingDate)) {
            $json['billingDate']          = $this->billingDate;
        }
        if (isset($this->businessDayOnly)) {
            $json['businessDayOnly']      = $this->businessDayOnly;
        }
        if (isset($this->endsAt)) {
            $json['endsAt']               = $this->endsAt;
        }
        if (isset($this->frequency)) {
            $json['frequency']            = Frequency2::checkValue($this->frequency);
        }
        if (isset($this->minAmount)) {
            $json['minAmount']            = $this->minAmount;
        }
        if (isset($this->originalPspReference)) {
            $json['originalPspReference'] = $this->originalPspReference;
        }
        if (isset($this->recurringAmount)) {
            $json['recurringAmount']      = $this->recurringAmount;
        }
        if (isset($this->recurringStatement)) {
            $json['recurringStatement']   = $this->recurringStatement;
        }
        if (isset($this->retryPolicy)) {
            $json['retryPolicy']          = $this->retryPolicy;
        }
        if (isset($this->startsAt)) {
            $json['startsAt']             = $this->startsAt;
        }

        return (!$asArrayWhenEmpty && empty($json)) ? new stdClass() : $json;
    }
}
